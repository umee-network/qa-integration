
    def test_query_registered_tokens(self):
        status, res = query_registered_tokens()
        self.assertTrue(status)
        self.assertEqual(len(res['registry']), 3, "It should have three tokens registered")

    # GH Issue: https://github.com/umee-network/umee/issues/1307
    def test_supply_withdraw(self): 
        # Query User A bank balance of uumee
        status, acc1_balance = query_balances(accounts0[0]["address"])
        self.assertTrue(status)
        print("\nAcc1 balances at start of supply/withdraw test: ", acc1_balance["balances"])
        self.assert_equal_balances(acc1_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000','uumee':'1000000000000'})

        # User A supplies between 10% and 90% of their uumee balance
        status = tx_supply(accounts0[0]["name"], "500000000000uumee", validator1_home)
        self.assertTrue(status)

        # Query User A bank balance of u/uumee
        status, acc1_balance = query_balances(accounts0[0]["address"])
        self.assertTrue(status)
        print("\nAcc1 balances after supplying 500000 umee: ", acc1_balance["balances"])
        self.assert_equal_balances(acc1_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000','u/uumee':'500000000000'})

        # User A withdraws between 10% and 90% of their u/uumee balance
        status = tx_withdraw(accounts0[0]["name"], "500000000000u/uumee", validator1_home)
        self.assertTrue(status)

        # Query User A bank balance of uumee
        status, acc1_balance = query_balances(accounts0[0]["address"])
        self.assertTrue(status)
        print("\nAcc1 balances after withdrawing 500000 u/umee: ", acc1_balance["balances"])
        self.assert_equal_balances(acc1_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000','uumee':'999999800000'})

    def test_supply_withdraw_atom(self):
        # Query User A bank balance of atom
        status, acc1_balance = query_balances(accounts0[0]["address"])
        self.assertTrue(status)
        print("\nAcc1 balances at start of supply/withdraw atom test: ", acc1_balance["balances"])
        self.assert_equal_balances(acc1_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000'})

        # User A supplies between 10% and 90% of their atom balance
        status = tx_supply(accounts0[0]["name"], "5000000000ibc/atom", validator1_home)
        self.assertTrue(status)

        # Query User A bank balance of u/ibc/atom
        status, acc1_balance = query_balances(accounts0[0]["address"])
        self.assertTrue(status)
        print("\nAcc1 balances after supplying 5000 atom: ", acc1_balance["balances"])
        self.assert_equal_balances(acc1_balance, {'ibc/atom':'5000000000','ibc/juno':'20000000000','u/ibc/atom':'5000000000'})

        # User A withdraws between 10% and 90% of their u/ibc/atom balance
        status = tx_withdraw(accounts0[0]["name"], "5000000000u/ibc/atom", validator1_home)
        self.assertTrue(status)

        # Query User A bank balance of atom
        status, acc1_balance = query_balances(accounts0[0]["address"])
        self.assertTrue(status)
        print("\nAcc1 balances after withdrawing 5000 u/atom: ", acc1_balance["balances"])
        self.assert_equal_balances(acc1_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000'})

    # GH Issue: https://github.com/umee-network/umee/issues/1210
    def test_simple_functional(self):
        # Submit exhange rates to price feeder every voting period in the background
        exchange_rate_set_thread1 = threading.Thread(target=self.exchange_rate_set, args=(EXCHANGE_RATES, validator1_val, validator1_home))
        exchange_rate_set_thread2 = threading.Thread(target=self.exchange_rate_set, args=(EXCHANGE_RATES, validator2_val, validator2_home))
        exchange_rate_set_thread3 = threading.Thread(target=self.exchange_rate_set, args=(EXCHANGE_RATES, validator3_val, validator3_home))
        exchange_rate_set_thread1.start()
        exchange_rate_set_thread2.start()
        exchange_rate_set_thread3.start()
        time.sleep(10)

        # Query User A and User B bank balance
        status, acc1_balance = query_balances(accounts0[0]["address"])
        self.assertTrue(status)
        print("\nAcc1 balances at start of simple functional test: ", acc1_balance["balances"])
        self.assert_equal_balances(acc1_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000','uumee':'999999600000'})
        status, acc2_balance = query_balances(accounts0[1]["address"])
        self.assertTrue(status)
        print("\nAcc2 balances at start of simple functional test: ", acc2_balance["balances"])
        self.assert_equal_balances(acc2_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000','uumee':'1000000000000'})

        # User A supplies and collaterlizes 10000 umee
        status = tx_supply(accounts0[0]["name"], "10000000000uumee", validator1_home)
        self.assertTrue(status)

        status = tx_collateralize(accounts0[0]["name"], "10000000000u/uumee", validator1_home)
        self.assertTrue(status)

        # User B supplies 2 atom
        status = tx_supply(accounts0[1]["name"], "2000000ibc/atom", validator1_home)
        self.assertTrue(status)

        status, acc1_balance = query_balances(accounts0[0]["address"])
        self.assertTrue(status)
        print("\nAcc1 balances after supplying and collateralizing 10000 umee: ", acc1_balance["balances"])
        self.assert_equal_balances(acc1_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000','uumee':'989999400000'})
        status, acc2_balance = query_balances(accounts0[1]["address"])
        self.assertTrue(status)
        print("\nAcc2 balances after supplying 2 atom: ", acc2_balance["balances"])
        self.assert_equal_balances(acc2_balance, {'ibc/atom':'9998000000','ibc/juno':'20000000000','u/ibc/atom':'2000000'})

        # User A borrows 1 atom
        status = tx_borrow(accounts0[0]["name"], "1000000ibc/atom", validator1_home)
        self.assertTrue(status)

        # User B withdraws 1 atom
        status = tx_withdraw(accounts0[1]["name"], "1000000u/ibc/atom", validator1_home)
        self.assertTrue(status)

        status, acc1_balance = query_balances(accounts0[0]["address"])
        self.assertTrue(status)
        print("\nAcc1 balances after borrowing 1 atom: ", acc1_balance["balances"])
        self.assert_equal_balances(acc1_balance, {'ibc/atom':'10001000000','ibc/juno':'20000000000'})
        status, acc2_balance = query_balances(accounts0[1]["address"])
        self.assertTrue(status)
        print("\nAcc2 balances after withdrawing 1 u/atom: ", acc2_balance["balances"])
        self.assert_equal_balances(acc2_balance, {'ibc/atom':'9999000000','ibc/juno':'20000000000','u/ibc/atom':'1000000'})

        # User A pays back 1 atom
        status = tx_repay(accounts0[0]["name"], "1000000ibc/atom", validator1_home)
        self.assertTrue(status)

        status, acc1_balance = query_balances(accounts0[0]["address"])
        self.assertTrue(status)
        print("\nAcc1 balances after repaying 1 atom: ", acc1_balance["balances"])
        self.assert_equal_balances(acc1_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000'})
        status, acc2_balance = query_balances(accounts0[1]["address"])
        self.assertTrue(status)
        print("\nAcc2 balances after acc1 repaid 1 atom: ", acc2_balance["balances"])
        self.assert_equal_balances(acc2_balance, {'ibc/atom':'9999000000','ibc/juno':'20000000000','u/ibc/atom':'1000000'})

        # Restore initial balances for User A and User B
        # User A decollateralizes and withdraws 10000 umee
        status = tx_decollateralize(accounts0[0]["name"], "10000000000u/uumee", validator1_home)
        self.assertTrue(status)
        status = tx_withdraw(accounts0[0]["name"], "10000000000u/uumee", validator1_home)
        self.assertTrue(status)

        # User B withdraws 1 atom
        status = tx_withdraw(accounts0[1]["name"], "1000000u/ibc/atom", validator1_home)
        self.assertTrue(status)

        status, acc1_balance = query_balances(accounts0[0]["address"])
        self.assertTrue(status)
        print("\nAcc1 balances at end of simple functional test: ", acc1_balance["balances"])
        self.assert_equal_balances(acc1_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000','uumee':'999999000000'})
        status, acc2_balance = query_balances(accounts0[1]["address"])
        self.assertTrue(status)
        print("\nAcc2 balances at end of simple functional test: ", acc2_balance["balances"])
        self.assert_equal_balances(acc2_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000','uumee':'999999700000'})

        # Stop exhange rate setting thread
        self.stop_exchange_rate_set = True
        exchange_rate_set_thread1.join()
        exchange_rate_set_thread2.join()
        exchange_rate_set_thread3.join()

    # GH Issue: https://github.com/umee-network/umee/issues/1207
    # Collateral weight and liquidation threshold is set to 0.75 so that borrow limit
    # for each account is 150 usd when supply and collateralizing 200 usd. Borrow rates
    # are set to 0 to make tracking changing balances simpler
    def test_functional_one(self):
        # Submit exhange rates to price feeder every voting period in the background
        print("\nStarting price voting threads")
        exchange_rate_set_thread1 = threading.Thread(target=self.exchange_rate_set, args=(EXCHANGE_RATES, validator1_val, validator1_home))
        exchange_rate_set_thread2 = threading.Thread(target=self.exchange_rate_set, args=(EXCHANGE_RATES, validator2_val, validator2_home))
        exchange_rate_set_thread3 = threading.Thread(target=self.exchange_rate_set, args=(EXCHANGE_RATES, validator3_val, validator3_home))
        exchange_rate_set_thread1.start()
        exchange_rate_set_thread2.start()
        exchange_rate_set_thread3.start()
        time.sleep(10)

        # account1, ..., account50 supply 10000 umee, account51, ..., account100 supply 1000 umee,
        # account101, ..., account200 supply 10000 atom and 200 juno
        t1 = threading.Thread(target=self.batch_supply, args=(accounts1, 0, 50, "10000000000uumee", validator1_home))
        t2 = threading.Thread(target=self.batch_supply, args=(accounts1, 50, 100, "1000000000uumee", validator1_home))
        t3 = threading.Thread(target=self.batch_supply, args=(accounts1, 100, 200, "1000000000ibc/atom", validator1_home))
        t4 = threading.Thread(target=self.batch_supply, args=(accounts1, 100, 200, "200000000ibc/juno", validator1_home))
        t1.start()
        t2.start()
        t3.start()
        t1.join()
        t2.join()
        t3.join()
        t4.start()
        t4.join()

        time.sleep(10)
        print("\nVoting threads started successfully")
        # account1, ..., account50 collateralize 10000 umee, account51, ..., account100 collateralize 1000 umee,
        # account101, ..., account200 collateralize 10000 atom and 200 juno
        print("\nStarting collateralize batches")
        t1 = threading.Thread(target=self.batch_collateralize, args=(accounts1, 0, 50, "10000000000u/uumee", validator1_home))
        t2 = threading.Thread(target=self.batch_collateralize, args=(accounts1, 50, 100, "1000000000u/uumee", validator1_home))
        t3 = threading.Thread(target=self.batch_collateralize, args=(accounts1, 100, 200, "1000000000u/ibc/atom", validator1_home))
        t4 = threading.Thread(target=self.batch_collateralize, args=(accounts1, 100, 200, "200000000u/ibc/juno", validator1_home))
        t1.start()
        t2.start()
        t3.start()
        t1.join()
        t2.join()
        t3.join()
        t4.start()
        t4.join()

        time.sleep(10)
        print("\nCollateralize batches run successfully")
        
        # Query account balances to make sure transactions went through correctly
        for i in range(0,49):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assertTrue(status)
            self.assert_equal_balances(acc_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000','lastlast':'989998800000'}) 
        for i in range(50,99):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assertTrue(status)
            self.assert_equal_balances(acc_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000','uumee':'998999800000'})
        for i in range(100,200):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assertTrue(status)
            self.assert_equal_balances(acc_balance, {'ibc/atom':'9000000000','ibc/juno':'19800000000','uumee':'999999600000'})

        # Every 1min, 9 times in total, acount51, ..., account100 supply and collateralize 1000 umee
        print("\nBatch supply and collateralize 1000umee")
        for _ in range(9):
            self.batch_supply(accounts1, 50, 100, "1000000000uumee", validator1_home)
            self.batch_collateralize(accounts1, 50, 100, "1000000000u/uumee", validator1_home)

        # Query account balances to make sure transactions went through correctly
        for i in range(0,49):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assert_equal_balances(acc_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000','uumee':'989999800000'}) 
        for i in range(50,99):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assert_equal_balances(acc_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000','uumee':'989998000000'}) 
        for i in range(100,200):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assertTrue(status)
            self.assert_equal_balances(acc_balance, {'ibc/atom':'9000000000','ibc/juno':'19800000000','uumee':'999999600000'})

        # In parallel, account1, ..., account20 borrow 10 atom, account21, ..., account40 borrow 100 atom,
        # account41, ..., account60 borrow 150 atom, account61, ..., account100 borrow 300 juno
        print("\nStarting 2nd batching threads")
        t1 = threading.Thread(target=self.batch_borrow, args=(accounts1, 0, 19, "10000000ibc/atom", validator1_home))
        t2 = threading.Thread(target=self.batch_borrow, args=(accounts1, 20, 39, "100000000ibc/atom", validator1_home))
        t3 = threading.Thread(target=self.batch_borrow, args=(accounts1, 40, 59, "150000000ibc/atom", validator1_home))
        t4 = threading.Thread(target=self.batch_borrow, args=(accounts1, 60, 100, "300000000ibc/juno", validator1_home))
        t1.start()
        t2.start()
        t3.start()
        t4.start()
        t1.join()
        t2.join()
        t3.join()
        t4.join()
        time.sleep(10)
        print("\n2nd batching threads finished")

        # Query account balances to make sure transactions went through correctly
        for i in range(0,19):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assertTrue(status)
            self.assert_equal_balances(acc_balance, {'ibc/atom':'10010000000','ibc/juno':'20000000000','uumee':'989999700000'})
        for i in range(20,39):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assertTrue(status)
            self.assert_equal_balances(acc_balance, {'ibc/atom':'10100000000','ibc/juno':'20000000000','uumee':'989999700000'})
        for i in range(40,50):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assertTrue(status)
            self.assert_equal_balances(acc_balance, {'ibc/atom':'10150000000','ibc/juno':'20000000000','uumee':'989999700000'}) 
        for i in range(51,59):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assertTrue(status)
            self.assert_equal_balances(acc_balance, {'ibc/atom':'10150000000','ibc/juno':'20000000000','uumee':'989997900000'})
        for i in range(60,100):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assertTrue(status)
            self.assert_equal_balances(acc_balance, {'ibc/atom':'10000000000','ibc/juno':'20300000000','uumee':'989997900000'})

        # Stop exhange rate setting thread
        self.stop_exchange_rate_set = True
        exchange_rate_set_thread1.join()
        exchange_rate_set_thread2.join()
        exchange_rate_set_thread3.join()

        # Price of atom grows to 2 usd, price of juno grows to 0.7 usd. Restart exchange rate setting with new rates
        self.stop_exchange_rate_set = False
        exchange_rate_set_thread1 = threading.Thread(target=self.exchange_rate_set, args=(UPDATED_EXCHANGE_RATES, validator1_val, validator1_home))
        exchange_rate_set_thread2 = threading.Thread(target=self.exchange_rate_set, args=(UPDATED_EXCHANGE_RATES, validator2_val, validator2_home))
        exchange_rate_set_thread3 = threading.Thread(target=self.exchange_rate_set, args=(UPDATED_EXCHANGE_RATES, validator3_val, validator3_home))
        exchange_rate_set_thread1.start()
        exchange_rate_set_thread2.start()
        exchange_rate_set_thread3.start()
        time.sleep(20)

        status, targets = query_liquidation_targets()
        self.assertTrue(status)
        self.assertEqual(len(targets['targets']), 78, "There should be 78 accounts able to be liquidated (i.e. acount22 - acount100)")  # Lastt

        for t in targets['targets']:
            status, summary = query_account_summary(t)
            self.assertTrue(status)
            self.assertTrue(summary['borrowed_value'] > summary['liquidation_threshold'], f'Account with address {t} should not be a liquidation target')

        # Query account summaries before liquidations
        for i in range(0,19):
            status, summary = query_account_summary(accounts1[i]["address"])
            self.assertTrue(status)
            print(f'Account summary for account{i+1} before liquidations: {summary}')
            self.assert_equal_summaries(summary, {'supplied_value': '200.000000000000000000', 'collateral_value': '200.000000000000000000', 'borrowed_value': '20.000000000000000000', 'borrow_limit': '150.000000000000000000', 'liquidation_threshold': '150.000000000000000000'})
        for i in range(20,39):
            status, summary = query_account_summary(accounts1[i]["address"])
            self.assertTrue(status)
            print(f'Account summary for account{i+1} before liquidations: {summary}')
            self.assert_equal_summaries(summary, {'supplied_value': '200.000000000000000000', 'collateral_value': '200.000000000000000000', 'borrowed_value': '200.000000000000000000', 'borrow_limit': '150.000000000000000000', 'liquidation_threshold': '150.000000000000000000'})
        for i in range(40,59):
            status, summary = query_account_summary(accounts1[i]["address"])
            self.assertTrue(status)
            print(f'Account summary for account{i+1} before liquidations: {summary}')
            self.assert_equal_summaries(summary, {'supplied_value': '200.000000000000000000', 'collateral_value': '200.000000000000000000', 'borrowed_value': '300.000000000000000000', 'borrow_limit': '150.000000000000000000', 'liquidation_threshold': '150.000000000000000000'})
        for i in range(60,100):
            status, summary = query_account_summary(accounts1[i]["address"])
            self.assertTrue(status)
            print(f'Account summary for account{i+1} before liquidations: {summary}')
            self.assert_equal_summaries(summary, {'supplied_value': '200.000000000000000000', 'collateral_value': '200.000000000000000000', 'borrowed_value': '210.000000000000000000', 'borrow_limit': '150.000000000000000000', 'liquidation_threshold': '150.000000000000000000'})


        # Liquidate whatever possible in parallel (acount21, ..., acount100)
        max_juno_ammount = 300000000 * (200/210) # Juno amount as 200 usd since that is amount collateralized
        t1 = threading.Thread(target=self.batch_liquidate, args=(liquidators1, accounts1, 20, 40, "100000000ibc/atom", "uumee", validator1_home))
        t2 = threading.Thread(target=self.batch_liquidate, args=(liquidators1, accounts1, 40, 60, "100000000ibc/atom", "uumee", validator1_home))
        t3 = threading.Thread(target=self.batch_liquidate, args=(liquidators1, accounts1, 60, 100, str(max_juno_ammount) + "ibc/juno", "uumee", validator1_home))
        t1.start()
        t2.start()
        t3.start()
        t1.join()
        t2.join()
        t3.join()

        time.sleep(10)

        # Query account balances to make sure transactions went through correctly and account summaries after liquidations
        for i in range(0,19):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assertTrue(status)
            print(f'Acc_balance for account{i+1}: {acc_balance}')
            status, liq_balance = query_balances(liquidators1[i]["address"])
            self.assertTrue(status)
            print(f'Acc_balance for liquidator{i+1}: {liq_balance}')
            self.assert_equal_balances(acc_balance, {'ibc/atom':'10010000000','ibc/juno':'20000000000','uumee':'989999700000'})
            self.assert_equal_balances(liq_balance, {'ibc/atom':'10000000000','ibc/juno':'20000000000','uumee':'1000000000000'})

            status, summary = query_account_summary(accounts1[i]["address"])
            self.assertTrue(status)
            print(f'Account summary for account{i+1} after liquidations: {summary}')
            self.assert_equal_summaries(summary, {'supplied_value': '200.000000000000000000', 'collateral_value': '200.000000000000000000', 'borrowed_value': '20.000000000000000000', 'borrow_limit': '150.000000000000000000', 'liquidation_threshold': '150.000000000000000000'})

            
        for i in range(20,39):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assertTrue(status)
            print(f'Acc_balance for account{i+1}: {acc_balance}')
            status, liq_balance = query_balances(liquidators1[i]["address"])
            self.assertTrue(status)
            print(f'Acc_balance for liquidator{i+1}: {liq_balance}')
            self.assert_equal_balances(acc_balance, {'ibc/atom':'10100000000','ibc/juno':'20000000000','uumee':'989999700000'})
            self.assert_equal_balances(liq_balance, {'ibc/atom':'9908256880','ibc/juno':'20000000000','uumee':'1009999900000'})

            status, summary = query_account_summary(accounts1[i]["address"])
            self.assertTrue(status)
            print(f'Account summary for account{i+1} after liquidations: {summary}')
            self.assert_equal_summaries(summary, {'supplied_value': '0.000000000000000000', 'collateral_value': '0.000000000000000000', 'borrowed_value': '16.513760000000000000', 'borrow_limit': '0.000000000000000000', 'liquidation_threshold': '0.000000000000000000'})
            
        for i in range(40,50):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assertTrue(status)
            print(f'Acc_balance for account{i+1}: {acc_balance}')
            status, liq_balance = query_balances(liquidators1[i]["address"])
            self.assertTrue(status)
            print(f'Acc_balance for liquidator{i+1}: {liq_balance}')
            self.assert_equal_balances(acc_balance, {'ibc/atom':'10150000000','ibc/juno':'20000000000','uumee':'989999700000'}) 
            self.assert_equal_balances(liq_balance, {'ibc/atom':'9908256880','ibc/juno':'20000000000','uumee':'1009999900000'})

            status, summary = query_account_summary(accounts1[i]["address"])
            self.assertTrue(status)
            print(f'Account summary for account{i+1} after liquidations: {summary}')
            self.assert_equal_summaries(summary, {'supplied_value': '0.000000000000000000', 'collateral_value': '0.000000000000000000', 'borrowed_value': '116.513760000000000000', 'borrow_limit': '0.000000000000000000', 'liquidation_threshold': '0.000000000000000000'})
            
        for i in range(51,59):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assertTrue(status)
            print(f'Acc_balance for account{i+1}: {acc_balance}')
            status, liq_balance = query_balances(liquidators1[i]["address"])
            self.assertTrue(status)
            print(f'Acc_balance for liquidator{i+1}: {liq_balance}')
            self.assert_equal_balances(acc_balance, {'ibc/atom':'10150000000','ibc/juno':'20000000000','uumee':'989997900000'}) 
            self.assert_equal_balances(liq_balance, {'ibc/atom':'9908256880','ibc/juno':'20000000000','uumee':'1009999900000'})

            status, summary = query_account_summary(accounts1[i]["address"])
            self.assertTrue(status)
            print(f'Account summary for account{i+1} after liquidations: {summary}')
            self.assert_equal_summaries(summary, {'supplied_value': '0.000000000000000000', 'collateral_value': '0.000000000000000000', 'borrowed_value': '116.513760000000000000', 'borrow_limit': '0.000000000000000000', 'liquidation_threshold': '0.000000000000000000'})
            
        for i in range(60,100):
            status, acc_balance = query_balances(accounts1[i]["address"])
            self.assertTrue(status)
            print(f'Acc_balance for account{i+1}: {acc_balance}')
            status, liq_balance = query_balances(liquidators1[i]["address"])
            self.assertTrue(status)
            print(f'Acc_balance for liquidator{i+1}: {liq_balance}')
            self.assert_equal_balances(acc_balance, {'ibc/atom':'10000000000','ibc/juno':'20300000000','uumee':'989997900000'})
            self.assert_equal_balances(liq_balance, {'ibc/atom':'10000000000','ibc/juno':'19737876802','uumee':'1009999899999'}) #last

            status, summary = query_account_summary(accounts1[i]["address"])
            self.assertTrue(status)
            print(f'Account summary for account{i+1} after liquidations: {summary}')
            self.assert_equal_summaries(summary, {'supplied_value': '0.000000020000000000', 'collateral_value': '0.000000020000000000', 'borrowed_value': '26.513761400000000000', 'borrow_limit': '0.000000015000000000', 'liquidation_threshold': '0.000000015000000000'})

        # Stop exhange rate setting thread
        self.stop_exchange_rate_set = True
        exchange_rate_set_thread1.join()
        exchange_rate_set_thread2.join()
        exchange_rate_set_thread3.join()
